<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/基础/文件与IO">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<title data-rh="true">文件与IO | jellyrain笔记小站</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jellyrain.github.io/learn/Java/基础/文件与IO"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="文件与IO | jellyrain笔记小站"><meta data-rh="true" name="description" content="1. File 类："><meta data-rh="true" property="og:description" content="1. File 类："><link data-rh="true" rel="icon" href="/learn/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jellyrain.github.io/learn/Java/基础/文件与IO"><link data-rh="true" rel="alternate" href="https://jellyrain.github.io/learn/Java/基础/文件与IO" hreflang="en"><link data-rh="true" rel="alternate" href="https://jellyrain.github.io/learn/Java/基础/文件与IO" hreflang="x-default"><link rel="stylesheet" href="/learn/assets/css/styles.b2a6bbef.css">
<link rel="preload" href="/learn/assets/js/runtime~main.ebd00b28.js" as="script">
<link rel="preload" href="/learn/assets/js/main.46749012.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/learn/"><div class="navbar__logo"><img src="/learn/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/learn/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Jellyrain</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/learn/">文档</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jellyrain" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/learn/">介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/DBeaver/DBeaver快捷键">DBeaver</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/DataBase/数据仓库/数据仓库概述">DataBase</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Hadoop/Hadoop简介">Hadoop</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Hive/Hive概述">Hive</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/learn/Java/Maven/简介">Java</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/Maven/简介">Maven</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/learn/Java/基础/简介">基础</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/简介">简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/">基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/运算符">运算符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/流程控制">流程控制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/数组">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/常用类">常用类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/String类">String类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/多线程">多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/泛型">泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/集合">集合</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/learn/Java/基础/文件与IO">文件与IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/网络编程">网络编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/反射">反射</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/Java8新特性/Lambda表达式">Java8新特性</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/异常/异常概述">异常</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/面向对象编程/面向对象描述">面向对象编程</a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Linux&amp;Shell/Linux/Linux概述">Linux&amp;Shell</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Markdown/Markdown 基本语法">Markdown</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/SQL/DCL/grant">SQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/XPath/XPath（基础）">XPath</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Zookeeper/Zookeeper概述">Zookeeper</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/web/HTML/HTML 介绍">web</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/正则表达式/正则表达式（基础）">正则表达式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/计算机网络/软件结构">计算机网络</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/learn/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">基础</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">文件与IO</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>文件与IO</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-file-类">1. File 类：<a class="hash-link" href="#1-file-类" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-file类概述">1. File类概述：<a class="hash-link" href="#1-file类概述" title="Direct link to heading">​</a></h4><p>File类是java.io包下代表与平台无关的文件和目录，也就是说如果希望在程序中操作文件和目录都可以通过File类来完成，File类能新建、删除、重命名文件和目录</p><p>在API中File的解释是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</p><blockquote><p>File类代表磁盘或网络中某个文件或目录的路径名称，如：/javase/io/xx.jpg</p><p>但不能直接通过File对象读取和写入数据，如果要操作数据，需要 <strong>IO流</strong>。File对象好比是到水库的“路线地址”，要“存取”里面的水到你“家里”，需要“管道”</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-构造方法">2. 构造方法：<a class="hash-link" href="#2-构造方法" title="Direct link to heading">​</a></h4><ul><li><p><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例  </p></li><li><p><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串 和 子路径名字符串</strong>创建新的 File实例</p></li><li><p><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名 和 子路径名字符串</strong>创建新的 File实例</p></li><li></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 文件路径名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String pathname = &quot;D:\\aaa.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">File file1 = new File(pathname); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 文件路径名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">File file2 = new File(pathname2); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过父路径和子路径字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> String parent = &quot;d:\\aaa&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> String child = &quot;bbb.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> File file3 = new File(parent, child);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过父级File对象和子路径字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">File parentDir = new File(&quot;d:\\aaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String child = &quot;bbb.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">File file4 = new File(parentDir, child);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-常用方法">3. 常用方法：<a class="hash-link" href="#3-常用方法" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-获取文件和目录基本信息的方法">1. 获取文件和目录基本信息的方法：<a class="hash-link" href="#1-获取文件和目录基本信息的方法" title="Direct link to heading">​</a></h5><ul><li><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称</li><li><code>public long length()</code>  ：返回由此File表示的文件的长度</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-各种路径问题">2. 各种路径问题：<a class="hash-link" href="#2-各种路径问题" title="Direct link to heading">​</a></h5><ul><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串</p></li><li><p><code>public String getParent()</code> ：获得父级路径</p></li><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径</p></li><li><p><strong>相对路径</strong>：相对于<strong>项目目录</strong>的路径，这是一个便捷的路径，开发中经常使用</p></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3-判断功能的方法">3. 判断功能的方法：<a class="hash-link" href="#3-判断功能的方法" title="Direct link to heading">​</a></h5><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件</li><li><code>public isAbsolute()</code>：判断File对象对应的文件或目录是否是绝对路径</li><li><code>public boolean canRead()</code>：判断File对象对应的文件或目录是否可读</li><li><code>public boolean canWrite()</code>：判断File对象对应的文件或目录是否可写</li><li><code>public boolean isHidden()</code>：判断File对象对应的文件或目录是否是否隐藏</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="4-创建删除功能的方法">4. 创建删除功能的方法<a class="hash-link" href="#4-创建删除功能的方法" title="Direct link to heading">​</a></h5><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件</li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  只能删除空目录</li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="5-目录的遍历">5. 目录的遍历：<a class="hash-link" href="#5-目录的遍历" title="Direct link to heading">​</a></h5><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-io流">2. IO流：<a class="hash-link" href="#2-io流" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-io流的概述">1. IO流的概述：<a class="hash-link" href="#1-io流的概述" title="Direct link to heading">​</a></h4><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等</p><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-io的分类">2. IO的分类：<a class="hash-link" href="#2-io的分类" title="Direct link to heading">​</a></h4><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul><li>以InputStream,Reader结尾</li></ul></li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul><li>以OutputStream、Writer结尾</li></ul></li></ul><p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul><li>以InputStream和OutputStream结尾</li></ul></li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul><li>以Reader和Writer结尾</li></ul></li></ul><p>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p><ul><li><p><strong>节点流</strong>：可以从或向一个特定的地方（节点）读写数据。如FileReader.</p></li><li><p><strong>处理流</strong>：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接</p></li></ul><blockquote><p>这种设计是装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一</p></blockquote><p><strong>常用的节点流：</strong> 　</p><ul><li>文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li><li>字符串 StringReader StringWriter 对字符串进行处理的节点流。</li><li>数 组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li>管 道 PipedInputStream、PipedOutputStream、PipedReader、PipedWriter对管道进行处理的节点流。</li></ul><p><strong>常用处理流：</strong></p><ul><li><p>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter---增加缓冲功能，避免频繁读写硬盘。</p></li><li><p>转换流：InputStreamReader、OutputStreamReader---实现字节流和字符流之间的转换。</p></li><li><p>数据流：DataInputStream、DataOutputStream -提供读写Java基础数据类型功能</p></li><li><p>对象流：ObjectInputStream、ObjectOutputStream--提供直接读写Java对象功能</p></li></ul><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<strong>InputStream</strong></td><td align="center">字节输出流<strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<strong>Reader</strong></td><td align="center">字符输出流<strong>Writer</strong></td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-字节流">3. 字节流：<a class="hash-link" href="#3-字节流" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-一切皆为字节">1. 一切皆为字节：<a class="hash-link" href="#1-一切皆为字节" title="Direct link to heading">​</a></h5><p><strong>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存</strong>，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-字节输出流outputstream">2. 字节输出流【OutputStream】：<a class="hash-link" href="#2-字节输出流outputstream" title="Direct link to heading">​</a></h5><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源</li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出</li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流</li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流</li></ul><blockquote><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源</p></blockquote><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3-fileoutputstream类">3. FileOutputStream类：<a class="hash-link" href="#3-fileoutputstream类" title="Direct link to heading">​</a></h5><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始</p><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1构造方法">1.构造方法：<a class="hash-link" href="#1构造方法" title="Direct link to heading">​</a></h6><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件</li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-写出字节数据">2. 写出字节数据：<a class="hash-link" href="#2-写出字节数据" title="Direct link to heading">​</a></h6><ul><li><p><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据</p></li><li><p><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据</p></li><li><p><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从 off 索引开始，len 个字节</p></li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-数据追加续写">3. 数据追加续写：<a class="hash-link" href="#3-数据追加续写" title="Direct link to heading">​</a></h6><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件</li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件</li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据（默认值）。这样创建的输出流对象，就可以指定是否追加续写了</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4-写出换行">4. 写出换行：<a class="hash-link" href="#4-写出换行" title="Direct link to heading">​</a></h6><p>Windows系统里，换行符号是<code>\r\n</code></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FOSWrite {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义字节数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] words = {97,98,99,100,101};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; words.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 写出一个字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fos.write(words[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 写出一个换行, 换行符号转成数组写出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fos.write(&quot;\r\n&quot;.getBytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fos.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一</li></ul></li></ul></blockquote><h5 class="anchor anchorWithStickyNavbar_LWe7" id="4-字节输入流inputstream">4. 字节输入流【InputStream】：<a class="hash-link" href="#4-字节输入流inputstream" title="Direct link to heading">​</a></h5><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源</p></blockquote><h5 class="anchor anchorWithStickyNavbar_LWe7" id="5-fileinputstream类">5. FileInputStream类：<a class="hash-link" href="#5-fileinputstream类" title="Direct link to heading">​</a></h5><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法">1. 构造方法：<a class="hash-link" href="#1-构造方法" title="Direct link to heading">​</a></h6><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> </p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-读取字节数据">2. 读取字节数据：<a class="hash-link" href="#2-读取字节数据" title="Direct link to heading">​</a></h6><ul><li><p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code></p></li><li><p><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> </p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FISRead {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义变量，作为有效个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len ；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义字节数组，作为装字节数据的容器   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] b = new byte[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 循环读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (( len= fis.read(b))!=-1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 每次读取后,把数组的有效字节部分，变成字符串打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fis.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-字符流">4. 字符流：<a class="hash-link" href="#4-字符流" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-字符输入流reader">1. 字符输入流【Reader】：<a class="hash-link" href="#1-字符输入流reader" title="Direct link to heading">​</a></h5><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源</li><li><code>public int read()</code>： 从输入流读取一个字符</li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 </li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-filereader类--">2. FileReader类  ：<a class="hash-link" href="#2-filereader类--" title="Direct link to heading">​</a></h5><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用<strong>系统默认的字符编码和默认字节缓冲区</strong>。</p><blockquote><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是 <strong>GBK</strong> 编码表</p><p>​	eclipse中默认GBK，idea中默认UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-1">1. 构造方法：<a class="hash-link" href="#1-构造方法-1" title="Direct link to heading">​</a></h6><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-读取字符数据">2. 读取字符数据：<a class="hash-link" href="#2-读取字符数据" title="Direct link to heading">​</a></h6><ul><li><p><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取</p></li><li><p><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> </p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FISRead {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileReader fr = new FileReader(&quot;read.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义变量，保存有效字符个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len ；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义字符数组，作为装字符数据的容器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char[] cbuf = new char[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 循环读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((len = fr.read(cbuf))!=-1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(new String(cbuf,0,len));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fr.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3-字符输出流writer">3. 字符输出流【Writer】：<a class="hash-link" href="#3-字符输出流writer" title="Direct link to heading">​</a></h5><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法</p><ul><li><code>void write(int c)</code> 写入单个字符</li><li><code>void write(char[] cbuf) </code>写入字符数组</li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数</li><li><code>void write(String str) </code>写入字符串</li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数</li><li><code>void flush() </code>刷新该流的缓冲</li><li><code>void close()</code> 关闭此流，但要先刷新它</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="4-filewriter类">4. FileWriter类：<a class="hash-link" href="#4-filewriter类" title="Direct link to heading">​</a></h5><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-2">1. 构造方法：<a class="hash-link" href="#1-构造方法-2" title="Direct link to heading">​</a></h6><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象 </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称</li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-基本写出数据">2. 基本写出数据：<a class="hash-link" href="#2-基本写出数据" title="Direct link to heading">​</a></h6><ul><li><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FWWrite {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(97); // 写出第1个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;b&#x27;); // 写出第2个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;C&#x27;); // 写出第3个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        【注意】关闭资源时,与FileOutputStream不同。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // fw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-关闭和刷新">3. 关闭和刷新：<a class="hash-link" href="#3-关闭和刷新" title="Direct link to heading">​</a></h6><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用</li><li><code>close </code> ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FWWrite {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据，通过flush</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;刷&#x27;); // 写出第1个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据，通过close</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;关&#x27;); // 写出第1个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h6 class="anchor anchorWithStickyNavbar_LWe7" id="4-写出其他数据">4. 写出其他数据：<a class="hash-link" href="#4-写出其他数据" title="Direct link to heading">​</a></h6><ul><li><p><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream</p></li><li><p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</p></li><li><p><strong>续写和换行</strong>：操作类似于FileOutputStream</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FWWrite {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用文件名称创建流对象，可以续写数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileWriter fw = new FileWriter(&quot;fw.txt&quot;，true);     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&quot;尚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出换行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&quot;\r\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.write(&quot;硅谷&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-缓冲流">5. 缓冲流：<a class="hash-link" href="#5-缓冲流" title="Direct link to heading">​</a></h4><p>缓冲流,也叫高效流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在<strong>创建流对象时</strong>，会<strong>创建一个内置的默认大小的缓冲区数组</strong>，通过<strong>缓冲区读写，减少系统IO次数</strong>，从而提高读写的效率（基本流是一个个读写，缓冲流是一批批读写）</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-字节缓冲流">1. 字节缓冲流：<a class="hash-link" href="#1-字节缓冲流" title="Direct link to heading">​</a></h5><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-3">1. 构造方法：<a class="hash-link" href="#1-构造方法-3" title="Direct link to heading">​</a></h6><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流</li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-示例">2. 示例：<a class="hash-link" href="#2-示例" title="Direct link to heading">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BufferedDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 记录开始时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long start = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 读写数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len; // 定义变量，作为有效个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] bytes = new byte[8*1024]; // 定义字节数组，作为装字节数据的容器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((len = bis.read(bytes)) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bos.write(bytes, 0 , len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bos.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bis.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 记录结束时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-字符缓冲流">2. 字符缓冲流：<a class="hash-link" href="#2-字符缓冲流" title="Direct link to heading">​</a></h5><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-4">1. 构造方法：<a class="hash-link" href="#1-构造方法-4" title="Direct link to heading">​</a></h6><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流</li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-特有方法">2. 特有方法：<a class="hash-link" href="#2-特有方法" title="Direct link to heading">​</a></h6><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字</li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号</li></ul><p><code>readLine</code>方法演示，代码如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BufferedReaderDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // 创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义字符串,保存读取的一行文字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String line  = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 循环读取,读取到最后返回null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((line = br.readLine())!=null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 释放资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        br.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>newLine</code>方法演示，代码如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BufferedWriterDemo throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) throws IOException  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.write(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出换行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.newLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.write(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.newLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.write(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.newLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 释放资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6-转换流字节-和-字符-互相转换">6. 转换流（字节 和 字符 互相转换）：<a class="hash-link" href="#6-转换流字节-和-字符-互相转换" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-字符编码和字符集">1. 字符编码和字符集：<a class="hash-link" href="#1-字符编码和字符集" title="Direct link to heading">​</a></h5><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-字符编码">1. 字符编码：<a class="hash-link" href="#1-字符编码" title="Direct link to heading">​</a></h6><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><p>编码:字符(能看懂的)--字节(看不懂的)</p><p>解码:字节(看不懂的)--&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-字符集">2. 字符集：<a class="hash-link" href="#2-字符集" title="Direct link to heading">​</a></h6><ul><li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</p><p><img loading="lazy" src="/learn/assets/images/1_charset-8ee816a3c9956edd324c4a3d96ee0081.jpg" width="1197" height="393" class="img_ev3q"></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。</li><li>ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&quot;全角&quot;字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了<strong>双字节</strong>编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用<strong>三个字节编码</strong>。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码</li></ol></li></ul></li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-inputstreamreader类--">2. InputStreamReader类  ：<a class="hash-link" href="#2-inputstreamreader类--" title="Direct link to heading">​</a></h5><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-5">1. 构造方法：<a class="hash-link" href="#1-构造方法-5" title="Direct link to heading">​</a></h6><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-示例-1">2. 示例：<a class="hash-link" href="#2-示例-1" title="Direct link to heading">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReaderDemo2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义文件路径,文件为gbk编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String FileName = &quot;E:\\file_gbk.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象,默认UTF8编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象,指定GBK编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义变量,保存字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用默认编码字符流读取,乱码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((read = isr.read()) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print((char)read); // ��Һ�</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isr.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用指定编码字符流读取,正常解析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while ((read = isr2.read()) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print((char)read);// 大家好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isr2.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3-outputstreamwriter类">3. OutputStreamWriter类：<a class="hash-link" href="#3-outputstreamwriter类" title="Direct link to heading">​</a></h5><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-6">1. 构造方法：<a class="hash-link" href="#1-构造方法-6" title="Direct link to heading">​</a></h6><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-示例-2">2. 示例：<a class="hash-link" href="#2-示例-2" title="Direct link to heading">​</a></h6><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class OutputDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义文件路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String FileName = &quot;E:\\out.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象,默认UTF8编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        osw.write(&quot;你好&quot;); // 保存为6个字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        osw.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 定义文件路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String FileName2 = &quot;E:\\out2.txt&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建流对象,指定GBK编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写出数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        osw2.write(&quot;你好&quot;);// 保存为4个字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        osw2.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="7-数据流">7. 数据流：<a class="hash-link" href="#7-数据流" title="Direct link to heading">​</a></h4><p>在程序代码中，要么将数据直接按照字节处理，要么按照字符处理。那么，如果要在程序中直接处理Java的基础数据类型，怎么办呢？</p><p>完成这个需求，可以使用DataOutputStream进行写，随后用DataInputStream进行读取，而且顺序要一致</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.DataInputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.DataOutputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.FileInputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.FileOutputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.IOException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestData {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void save() throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String name = &quot;巫师&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int age = 300;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char gender = &#x27;男&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int energy = 5000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        double price = 75.5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean relive = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;game.dat&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeUTF(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeInt(age);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeChar(gender);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeInt(energy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeDouble(price);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.writeBoolean(relive);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dos.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void reload()throws IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;game.dat&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String name = dis.readUTF();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int age = dis.readInt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char gender = dis.readChar();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int energy = dis.readInt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        double price = dis.readDouble();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean relive = dis.readBoolean();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name+&quot;,&quot; + age + &quot;,&quot; + gender + &quot;,&quot; + energy + &quot;,&quot; + price + &quot;,&quot; + relive);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dis.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8-序列化字节-和-对象-互相转换">8. 序列化（字节 和 对象 互相转换）：<a class="hash-link" href="#8-序列化字节-和-对象-互相转换" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="1-序列化概述">1. 序列化概述：<a class="hash-link" href="#1-序列化概述" title="Direct link to heading">​</a></h5><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在<strong>内存中创建对象</strong></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="2-objectoutputstream类">2. ObjectOutputStream类：<a class="hash-link" href="#2-objectoutputstream类" title="Direct link to heading">​</a></h5><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储</p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-7">1. 构造方法：<a class="hash-link" href="#1-构造方法-7" title="Direct link to heading">​</a></h6><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-序列化操作">2. 序列化操作：<a class="hash-link" href="#2-序列化操作" title="Direct link to heading">​</a></h6><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> <ul><li>如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现<code>Serializable</code> 接口</li></ul></li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰</li><li><strong>静态变量的值不会序列化</strong></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Employee implements java.io.Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String company = &quot;尚硅谷&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public transient int age; // transient瞬态修饰成员,不会被序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addressCheck() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SerializeDemo{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String [] args)   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee e = new Employee();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.name = &quot;zhangsan&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.address = &quot;beiqinglu&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.age = 20; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建序列化流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 写出对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.writeObject(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 释放资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fileOut.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch(IOException i)   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输出结果：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Serialized data is saved</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="3-objectinputstream类">3. ObjectInputStream类：<a class="hash-link" href="#3-objectinputstream类" title="Direct link to heading">​</a></h5><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-8">1. 构造方法：<a class="hash-link" href="#1-构造方法-8" title="Direct link to heading">​</a></h6><ul><li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream</li></ul><h6 class="anchor anchorWithStickyNavbar_LWe7" id="2-反序列化操作1">2. 反序列化操作1：<a class="hash-link" href="#2-反序列化操作1" title="Direct link to heading">​</a></h6><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class DeserializeDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public static void main(String [] args)   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee e = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // 创建反序列化流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             ObjectInputStream in = new ObjectInputStream(fileIn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // 读取一个对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             e = (Employee) in.readObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // 释放资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             in.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             fileIn.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(IOException i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // 捕获其他异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             i.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(ClassNotFoundException c)  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 捕获类找不到异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             System.out.println(&quot;Employee class not found&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             c.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 无异常,直接打印输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Name: &quot; + e.name);  // zhangsan</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Address: &quot; + e.address); // beiqinglu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;age: &quot; + e.age); // 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong></p><h6 class="anchor anchorWithStickyNavbar_LWe7" id="3-反序列化操作2">3. <strong>反序列化操作2</strong>：<a class="hash-link" href="#3-反序列化操作2" title="Direct link to heading">​</a></h6><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型  </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Employee implements java.io.Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 加入序列版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     private static final long serialVersionUID = 1L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public String address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public int eid; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public void addressCheck() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-printstreamsystemin和out">3. PrintStream、System.in和out：<a class="hash-link" href="#3-printstreamsystemin和out" title="Direct link to heading">​</a></h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-构造方法-9">1. 构造方法：<a class="hash-link" href="#1-构造方法-9" title="Direct link to heading">​</a></h4><ul><li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-改变打印流向">2. 改变打印流向：<a class="hash-link" href="#2-改变打印流向" title="Direct link to heading">​</a></h4><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个&quot;小把戏&quot;，改变它的流向</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class PrintDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用系统的打印流,控制台直接输出97</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(97);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建打印流,指定文件的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置系统的打印流流向,输出到ps.txt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.setOut(ps);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用系统的打印流,ps.txt中输出97</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(97);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-jdk17之后引入新trycatch">4. JDK1.7之后引入新try..catch：<a class="hash-link" href="#4-jdk17之后引入新trycatch" title="Direct link to heading">​</a></h3><p>它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/learn/Java/基础/集合"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">集合</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/learn/Java/基础/网络编程"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">网络编程</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-file-类" class="table-of-contents__link toc-highlight">1. File 类：</a></li><li><a href="#2-io流" class="table-of-contents__link toc-highlight">2. IO流：</a></li><li><a href="#3-printstreamsystemin和out" class="table-of-contents__link toc-highlight">3. PrintStream、System.in和out：</a></li><li><a href="#4-jdk17之后引入新trycatch" class="table-of-contents__link toc-highlight">4. JDK1.7之后引入新try..catch：</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/learn/assets/js/runtime~main.ebd00b28.js"></script>
<script src="/learn/assets/js/main.46749012.js"></script>
</body>
</html>