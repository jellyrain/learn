<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Java/基础/集合">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<title data-rh="true">集合 | jellyrain笔记小站</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jellyrain.github.io/learn/Java/基础/集合"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="集合 | jellyrain笔记小站"><meta data-rh="true" name="description" content="1. 数据结构："><meta data-rh="true" property="og:description" content="1. 数据结构："><link data-rh="true" rel="icon" href="/learn/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jellyrain.github.io/learn/Java/基础/集合"><link data-rh="true" rel="alternate" href="https://jellyrain.github.io/learn/Java/基础/集合" hreflang="en"><link data-rh="true" rel="alternate" href="https://jellyrain.github.io/learn/Java/基础/集合" hreflang="x-default"><link rel="stylesheet" href="/learn/assets/css/styles.178c7531.css">
<link rel="preload" href="/learn/assets/js/runtime~main.033937ee.js" as="script">
<link rel="preload" href="/learn/assets/js/main.4c2c454e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/learn/"><div class="navbar__logo"><img src="/learn/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/learn/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jellyrain</b></a><a class="navbar__item navbar__link navbar__link--active" href="/learn/">文档</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jellyrain" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/learn/">介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/web/HTML/HTML 介绍">web</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/learn/Java/Maven/简介">Java</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/Maven/简介">Maven</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/learn/Java/基础/简介">基础</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/简介">简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/">基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/运算符">运算符</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/流程控制">流程控制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/数组">数组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/常用类">常用类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/String类">String类</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/多线程">多线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/泛型">泛型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/learn/Java/基础/集合">集合</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/文件与IO">文件与IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/网络编程">网络编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/learn/Java/基础/反射">反射</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/Java8新特性/Lambda表达式">Java8新特性</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/异常/异常概述">异常</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/learn/Java/基础/面向对象编程/面向对象描述">面向对象编程</a></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Git/Git 介绍">Git</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/深度学习/前置知识/数据操作">深度学习</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Linux&amp;Shell/Linux/Linux概述">Linux&amp;Shell</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/DataBase/DBeaver/DBeaver快捷键">DataBase</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/SQL/DCL/grant">SQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Hadoop/Hadoop简介">Hadoop</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/Markdown/Markdown 基本语法">Markdown</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/正则表达式/正则表达式（基础）">正则表达式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/XPath/XPath（基础）">XPath</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/计算机网络/软件结构">计算机网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/learn/破解/说明">破解</a></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/learn/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><span class="breadcrumbs__link" itemprop="item name">Java</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><span class="breadcrumbs__link" itemprop="item name">基础</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">集合</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>集合</h1></header><h3 class="anchor anchorWithStickyNavbar_mojV" id="1-数据结构">1. 数据结构：<a class="hash-link" href="#1-数据结构" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-数据结构概述">1. 数据结构概述：<a class="hash-link" href="#1-数据结构概述" title="Direct link to heading">​</a></h4><p><strong>数据结构 </strong>就是研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型</p><ol><li>多个数据存储特点（在内存中如何存储）</li><li>多个数据之间的关系</li></ol><p>数据的逻辑结构指反映数据元素之间的逻辑关系，而与他们在计算机中的存储位置无关：</p><ul><li>集合（数学中集合的概念）：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系</li><li>线性结构：数据结构中的元素存在一对一的相互关系</li><li>树形结构：数据结构中的元素存在一对多的相互关系</li><li>图形结构：数据结构中的元素存在多对多的相互关系</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-顺序结存储结构">2. 顺序结存储结构：<a class="hash-link" href="#2-顺序结存储结构" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_mojV" id="1-数组">1. 数组：<a class="hash-link" href="#1-数组" title="Direct link to heading">​</a></h5><p>逻辑结构：线性的</p><p>物理结构：连续的存储空间</p><p>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了</p><p>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔</p><p><strong>整型数组：</strong></p><p><img loading="lazy" src="data:image/png;base64,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Vvru8xw4Vk/dhBHMLEz4h+eCotJIjUoj9YsHjn7Kux+v4tU3yqgkm7FdnlY0+/MMgqLSSBkwmX7mGqzt7bTbnGcY4QJbC3W1voTnZ5EzPANdqiQAJnMEScNuJD/SiZethZaOs7jpur2NpgYwJSTTe2I+CWhq0sUiICqVlAFT6BdcR4e1nXb7GbY9bhd0NlNf60NY70xyR2QS2zVR5T8UnjGczKx8UnxrqWq24TzTd545bdjbrVTXmMm4vD8ZadFohlnP5+MXRELhtfSJ9cPf0UST9Wz2Ie20NLohPIH8Ky0keXvpk/cu5uV2u/WtvSIiIiIi55nOaIuIiIiIGEBFW0RERETEACraIiIiIiIGUNEWERERETGAiraIiIiIiAFUtEVEREREDKCiLSIiIiJiABVtEREREREDqGiLiIiIiBhARVtERERExAAq2iIiIiIiBlDRFhERERExgIq2iIiIiIgBVLRFRERERAygoi0iIiIiYgAVbRERERERA6hoi4iIiIgYQEVbRERERMQAKtoiIiIiIgZQ0RYRERERMYCKtoiIiIiIAVS0RUREREQMoKItIiIiImIAFW0REREREQOoaIuIiIiIGEBFW0RERETEACraIiIiIiIGUNEWERERETGAiraIiIiIiAF8z3bBu+++m/379xuZRURERETEY2644QZuvvnm8/Z6Z120i4uLSU9PZ8iQIefth0vP1NDQwFNPPcXNN99MZmamp+NIN3fw4EEWLFjAnDlzCAsL83Qc6eY2bdrE5s2bueeeezwdRS4AK1asoKmpiVmzZnk6ilwA5s2bR1lZ2Xl9zbMu2gCTJk3itttuO68BpOc5cuQIzz77LNdddx1jx471dBzp5j788EPeeust7rjjDpKTkz0dR7q5F154gaNHjzJ37lxPR5ELQE1NDceOHdP7Rc5KcXHxeX9NzdEWERERETGAiraIiIiIiAFUtEVEREREDKCiLSIiIiJiABVtEREREREDqGiLiIiIiBhARVtERERExAAq2iIiIiIiBlDRFhERERExgIq2iIiIiIgBVLRFRERERAygoi0iIiIiYgAVbRERERERA6hoi4iIiIgYQEVbRERERMQAKtoiIiIiIgZQ0RYRERERMYCKtoiIiIiIAVS0RUREREQMoKItIiIiImIAFW0REREREQOoaIuIiIiIGEBFW0RERETEACra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" width="730" height="136" class="img_E7b_"></p><p><strong>对象数组：</strong></p><p><img loading="lazy" src="/learn/assets/images/1563432696340-b6d1bd0dc733e5e2fb42b9d854b31ccd.png" width="721" height="248" class="img_E7b_"></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-链式存储结构">3. 链式存储结构：<a class="hash-link" href="#3-链式存储结构" title="Direct link to heading">​</a></h4><p>逻辑结构：有线性的和非线性的</p><p>物理结构：不要求连续的存储空间</p><p>存储特点：数据必须封装到“结点”中，结点包含多个数据项，数据值只是其中的一个数据项，其他的数据项用来记录与之有关的结点的地址</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="1-单链表">1. 单链表：<a class="hash-link" href="#1-单链表" title="Direct link to heading">​</a></h5><p>元素节点 和 指向下一个节点指针</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="2-双链表">2. 双链表：<a class="hash-link" href="#2-双链表" title="Direct link to heading">​</a></h5><p>元素节点 和 指向上一个节点指针、指向下一个节点指针</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="3-循环单链表">3. 循环单链表：<a class="hash-link" href="#3-循环单链表" title="Direct link to heading">​</a></h5><p>元素节点 和 指向下一个节点指针，最后一个节点指向头节点</p><p><img loading="lazy" src="/learn/assets/images/1563448858180-c5c5eb0225b062d964895968f35ed18c.png" width="556" height="174" class="img_E7b_"></p><h5 class="anchor anchorWithStickyNavbar_mojV" id="4-二叉树">4. 二叉树<a class="hash-link" href="#4-二叉树" title="Direct link to heading">​</a></h5><p><img loading="lazy" src="/learn/assets/images/1563449427345-32747e467d28f9ff3190c226433891db.png" width="580" height="245" class="img_E7b_"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-集合概述">2. 集合概述：<a class="hash-link" href="#2-集合概述" title="Direct link to heading">​</a></h3><ul><li>集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢 ？</p><ul><li>数组的长度是固定的。集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储</li></ul><p>为了可以满足用户数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型。这些接口和类在 <strong>java.util</strong> 包中，因为类型很丰富，因此我们通常称为集合框架集</p><p>集合主要分为两大系列：<strong>Collection</strong> 和 <strong>Map</strong>，<strong>Collection</strong> 表示一组对象，<strong>Map </strong>表示一组映射关系或键值对</p><ul><li><p>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 </p><ul><li>List：<strong>有序的 collection</strong>（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li><li>Queue：<strong>队列</strong>通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li><li>Set：<strong>一个不包含重复元素的 collection</strong>。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。 </li><li>SortedSet 进一步<strong>提供关于元素的总体排序 的 Set</strong>。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li></ul></li><li><p>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p><ul><li>SortedMap 进一步<strong>提供关于键的总体排序 的 Map</strong>。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-collection-常用方法">3. Collection 常用方法：<a class="hash-link" href="#3-collection-常用方法" title="Direct link to heading">​</a></h3><p><code>Collection&lt;E&gt;</code> 是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><p><strong>1、添加元素</strong></p><p>（1）<strong>add</strong>(E obj)：添加元素对象到当前集合中</p><p>（2）<strong>addAll</strong>(Collection&lt;? extends E&gt; other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other</p><p><strong>2、删除元素</strong></p><p> （1） boolean <strong>remove</strong>(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素</p><p> （2）boolean <strong>removeAll</strong>(Collection&lt;?&gt; coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll</p><p><strong>3、判断元素</strong></p><p>（1）boolean <strong>isEmpty</strong>()：判断当前集合是否为空集合</p><p>（2）boolean <strong>contains</strong>(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素</p><p>（3）boolean <strong>containsAll</strong>(Collection&lt;?&gt; c)：判断c集合中的元素是否在当前集合中都存在。即c集合是否是当前集合的“子集”</p><p><strong>4、查询</strong></p><p>（1）int <strong>size</strong>()：获取当前集合中实际存储的元素个数</p><p>（2）Object[] <strong>toArray</strong>()：返回包含当前集合中所有元素的数组</p><p><strong>5、交集</strong></p><p>（1）boolean <strong>retainAll</strong>(Collection&lt;?&gt; coll)：当前集合仅保留与c集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  = this ∩ coll</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="4-iterator迭代器">4. Iterator迭代器：<a class="hash-link" href="#4-iterator迭代器" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="1--iterator接口">1.  Iterator接口：<a class="hash-link" href="#1--iterator接口" title="Direct link to heading">​</a></h4><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回 迭代的下一个元素</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true</li><li><code>public void remove()</code>:删除当前指针指向的元素（因为 Collection 的 remove 方法，无法根据条件删除）</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class IteratorDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用多态方式 创建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加元素到集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        coll.add(&quot;串串星人&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        coll.add(&quot;吐槽星人&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        coll.add(&quot;汪星人&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //使用迭代器 遍历   每个集合对象都有自己的迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;String&gt; it = coll.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  泛型指的是 迭代出 元素的数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(it.hasNext()){ //判断是否有迭代元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s = it.next();//获取迭代出的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><blockquote><p>tips：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的 next 方法，将会发生java.util.NoSuchElementException 没有集合元素的错误</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-迭代器实现原理">2. 迭代器实现原理：<a class="hash-link" href="#2-迭代器实现原理" title="Direct link to heading">​</a></h4><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</p><p><img loading="lazy" src="/learn/assets/images/迭代器原理图-c82bc1b3e981cf71d4c22a339aa1dde5.bmp" width="676" height="286" class="img_E7b_"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-增强for循环">3. 增强for循环：<a class="hash-link" href="#3-增强for循环" title="Direct link to heading">​</a></h4><p>增强for循环(也称for each循环)是 <strong>JDK1.5</strong> 以后出来的一个高级for循环，专门用来遍历数组和集合的。</p><p>格式：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">for(元素的数据类型  变量 : Collection集合or数组){ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //写操作代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>它用于遍历Collection和数组。通常只进行遍历元素，<strong>不要在遍历的过程中对集合元素进行增删操作</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class NBForDemo1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] arr = {3,5,6,87};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //使用增强for遍历数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(int a : arr){//a代表数组中的每个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="4-javalangiterable接口">4. java.lang.Iterable接口：<a class="hash-link" href="#4-javalangiterable接口" title="Direct link to heading">​</a></h4><p>java.lang.Iterable接口，实现这个接口允许对象成为 &quot;foreach&quot; 语句的目标 </p><p>Java 5时Collection接口继承了java.lang.Iterable接口，因此Collection系列的集合就可以直接使用foreach循环遍历</p><p>java.lang.Iterable接口的抽象方法：</p><ul><li>public Iterator iterator(): 获取对应的迭代器，用来遍历数组或集合中的元素的</li></ul><p>因为 foreach 本质上就是使用Iterator迭代器进行遍历的，所以也不要在 foreach 遍历的过程使用Collection的remove()方法。否则，要么报异常 java.util.ConcurrentModificationException，要么行为不确定</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="5-java中modcount的用法快速失败fail-fast机制">5. Java中modCount的用法，快速失败（fail-fast）机制：<a class="hash-link" href="#5-java中modcount的用法快速失败fail-fast机制" title="Direct link to heading">​</a></h4><p>当使用foreach或Iterator迭代器遍历集合时，同时调用迭代器自身以外的方法修改了集合的结构，例如调用集合的add和remove方法时，就会报ConcurrentModificationException</p><p>如果在Iterator、ListIterator迭代器创建后的任意时间从结构上修改了集合（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险</p><p>这样设计是因为，迭代器代表集合中某个元素的位置，内部会存储某些能够代表该位置的信息。当集合发生改变时，该信息的含义可能会发生变化，这时操作迭代器就可能会造成不可预料的事情。因此，果断抛异常阻止，是最好的方法。这就是Iterator迭代器的<strong>快速失败（fail-fast）机制</strong></p><p>迭代器的快速失败行为不能得到保证，一般来说，<strong>存在不同步的并发修改时，不可能作出任何坚决的保证</strong>（<strong>在高并发下不一定马上抛出异常</strong>）。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的方式是错误的，正确做法是：*迭代器的快速失败行为应该仅用于检测 bug</p><p>那么如何实现快速失败（fail-fast）机制的呢？</p><ul><li>在ArrayList等集合类中都有一个modCount变量。它用来记录集合的结构被修改的次数</li><li>当我们给集合添加和删除操作时，会导致modCount++</li><li>然后当我们用Iterator迭代器遍历集合时，创建集合迭代器的对象时，用一个变量记录当前集合的modCount。例如：<code>int expectedModCount = modCount;</code>，并且在迭代器每次next()迭代元素时，都要检查 <code>expectedModCount != modCount</code>，如果不相等了，那么说明你调用了Iterator迭代器以外的Collection的add,remove等方法，修改了集合的结构，使得modCount++，值变了，就会抛出ConcurrentModificationException</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="5-list集合">5. List集合：<a class="hash-link" href="#5-list集合" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-list接口概述">1. List接口概述：<a class="hash-link" href="#1-list接口概述" title="Direct link to heading">​</a></h4><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p><p>List接口特点：</p><ol><li>List集合所有的元素是以一种线性方式进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）</li><li>它是一个元素<strong>存取有序的集合</strong>。即元素的存入顺序和取出顺序一致</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</li></ol><p>注意：</p><p>List集合<strong>关心元素是否有序，而不关心是否重复</strong></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-list接口常用方法">2. List接口常用方法：<a class="hash-link" href="#2-list接口常用方法" title="Direct link to heading">​</a></h4><p>list除了从Collection集合<strong>继承的方法外</strong>，List 集合里添加了一些根据索引来操作集合元素的方法。</p><p><strong>1、添加元素</strong></p><ul><li>void <strong>add</strong>(int index, E ele)</li><li>boolean <strong>addAll</strong>(int index, Collection&lt;? extends E&gt; eles)</li></ul><p><strong>2、获取元素</strong></p><ul><li>E <strong>get</strong>(int index)</li><li>List <strong>subList</strong>(int fromIndex, int toIndex)</li></ul><p><strong>3、获取元素索引</strong></p><ul><li>int <strong>indexOf</strong>(Object obj)</li><li>int <strong>lastIndexOf</strong>(Object obj)</li></ul><p><strong>4、删除和替换元素</strong></p><ul><li>E <strong>remove</strong>(int index)</li><li>E <strong>set</strong>(int index, E ele)</li></ul><blockquote><p>在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-list的实现类">3. List的实现类：<a class="hash-link" href="#3-list的实现类" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_mojV" id="1-arraylist集合">1. ArrayList集合：<a class="hash-link" href="#1-arraylist集合" title="Direct link to heading">​</a></h5><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。<strong>元素增删慢，查找快</strong>，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class CollectionDemo4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加10个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt;=10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            list.add(&quot;java&quot;+i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.add(&quot;mysql&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="2-vector集合">2. Vector集合：<a class="hash-link" href="#2-vector集合" title="Direct link to heading">​</a></h5><p>ArrayList与Vector的区别？</p><p>它们的底层物理结构都是数组，我们称为动态数组。</p><ul><li><strong>ArrayList是新版的动态数组，线程不安全，效率高</strong>，<strong>Vector是旧版的动态数组，线程安全，效率低</strong></li><li>动态数组的扩容机制不同，<strong>ArrayList扩容为原来的1.5倍</strong>，<strong>Vector扩容增加为原来的2倍</strong></li><li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，<strong>没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10</strong>，而<strong>JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组</strong></li><li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class CollectionDemo4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; list = new Vector&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加10个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 1; i &lt;=10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            list.add(&quot;java&quot;+i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.add(&quot;mysql&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="3-linkedlist集合">3. LinkedList集合：<a class="hash-link" href="#3-linkedlist集合" title="Direct link to heading">​</a></h5><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列</p><p><img loading="lazy" src="data:image/png;base64,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" width="651" height="191" class="img_E7b_"></p><p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）<strong>堆栈</strong>。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p><table><thead><tr><th>堆栈方法</th><th>等效Deque方法</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>用作<strong>队列</strong>时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。</p><table><thead><tr><th>Queue 方法</th><th>等效 Deque 方法</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>操作位置描述：</p><table><thead><tr><th></th><th>第一个元素（头部）</th><th>第一个元素（头部）</th><th>最后一个元素（尾部）</th><th>最后一个元素（尾部）</th></tr></thead><tbody><tr><td></td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>移除</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>检查</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_mojV" id="4-listiterator">4. ListIterator：<a class="hash-link" href="#4-listiterator" title="Direct link to heading">​</a></h4><p>List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p><ul><li>void add()：通过迭代器添加元素到对应集合</li><li>void set(Object obj)：通过迭代器替换正迭代的元素</li><li>void remove()：通过迭代器删除刚迭代的元素</li><li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li><li>Object previous()：返回列表中的前一个元素。</li><li>int previousIndex()：返回列表中的前一个元素的索引</li><li>boolean hasNext()</li><li>Object next()</li><li>int nextIndex()</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="6-set集合">6. Set集合：<a class="hash-link" href="#6-set集合" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-set集合概述">1. Set集合概述：<a class="hash-link" href="#1-set集合概述" title="Direct link to heading">​</a></h4><p>Set接口是Collection的子接口，<strong>set接口没有提供额外的方法</strong>。<strong>但是比<code>Collection</code>接口更加严格了</strong>。</p><p>Set 集合<strong>不允许包含相同的元素</strong>，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p><p>Set集合支持的<strong>遍历方式和Collection集合一样</strong>：foreach和Iterator。</p><p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSe</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-hashset">1. HashSet：<a class="hash-link" href="#1-hashset" title="Direct link to heading">​</a></h4><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类</p><p><code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，然后HashMap的底层物理实现是一个Hash表</p><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。HashSet 集合判断两个元素相等的标准：<strong>两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等</strong>。因此，<strong>存储到HashSet的元素要重写hashCode和equals方法</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashSet;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestHashSet {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;all&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashSet&lt;Employee&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set.add(new Employee(&quot;张三&quot;, new MyDate(1990,1,1)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //重复元素无法添加，因为MyDate和Employee重写了hashCode和equals方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set.add(new Employee(&quot;张三&quot;, new MyDate(1990,1,1)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set.add(new Employee(&quot;李四&quot;, new MyDate(1992,2,2)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Employee object : set) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(object);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-linkedhashset">2. LinkedHashSet：<a class="hash-link" href="#2-linkedhashset" title="Direct link to heading">​</a></h4><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，<strong>在结点中增加两个属性before和after维护了结点的前后添加顺序</strong>。<code>java.util.LinkedHashSet</code>，它是<strong>链表和哈希表组合</strong>的一个数据存储结构。<strong>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能</strong></p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;张三&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;李四&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;王五&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;张三&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;元素个数：&quot; + set.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (String name : set) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">运行结果：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">元素个数：3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">张三</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">李四</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">王五</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-treeset">3. TreeSet：<a class="hash-link" href="#3-treeset" title="Direct link to heading">​</a></h4><p>底层结构：里面维护了一个TreeMap，都是基于 <strong>红黑树</strong> 实现的！</p><p>特点：
1、不允许重复
2、实现排序
自然排序或定制排序</p><p>如何实现去重的？</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">如果使用的是自然排序，则通过调用实现的compareTo方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果使用的是定制排序，则通过调用比较器的compare方法</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><p>如何排序？</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">方式一：自然排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">让待添加的元素类型实现Comparable接口，并重写compareTo方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">方式二：定制排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">创建Set对象时，指定Comparator比较器接口，并实现compare方法</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h5 class="anchor anchorWithStickyNavbar_mojV" id="1-自然顺序">1. 自然顺序：<a class="hash-link" href="#1-自然顺序" title="Direct link to heading">​</a></h5><p>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值为0</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="2-定制排序">2. 定制排序：<a class="hash-link" href="#2-定制排序" title="Direct link to heading">​</a></h5><p>如果放到TreeSet中的元素的自然排序（Comparable）规则不符合当前排序需求时，或者元素的类型没有实现Comparable接口。那么在创建TreeSet时，可以单独指定一个Comparator的对象。使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="7-map集合">7. Map集合：<a class="hash-link" href="#7-map集合" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="1-map集合的概述">1. Map集合的概述：<a class="hash-link" href="#1-map集合的概述" title="Direct link to heading">​</a></h4><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map&lt;K,V&gt;</code>接口</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map&lt;K,V&gt;</code>接口下的集合与<code>Collection&lt;E&gt;</code>接口下的集合，它们存储数据的形式不同</p><ul><li><code>Collection</code>中的集合，<strong>元素是孤立存在的（理解为单身）</strong>，向集合中存储元素采用一个个元素的方式存储</li><li><code>Map</code>中的集合，<strong>元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成</strong>，通过键可以找对所对应的值</li><li><strong><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合</strong></li><li>需要注意的是，<code>Map</code>中的集合<strong>不能包含重复的键，值可以重复</strong>；<strong>每个键只能对应一个值</strong>（这个值可以是单个值，也可以是个数组或集合值）</li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="2-map集合常用方法">2. Map集合常用方法：<a class="hash-link" href="#2-map集合常用方法" title="Direct link to heading">​</a></h4><p><strong>1、添加操作</strong></p><ul><li>V <strong>put</strong>(K key,V value)</li><li>void <strong>putAll</strong>(Map&lt;? extends K,? extends V&gt; m)</li></ul><p><strong>2、删除</strong></p><ul><li><p>void <strong>clear</strong>()</p></li><li><p>V <strong>remove</strong>(Object key)</p><p><strong>3、元素查询的操作</strong></p></li><li><p>V <strong>get</strong>(Object key)</p></li><li><p>boolean <strong>containsKey</strong>(Object key)</p></li><li><p>boolean <strong>containsValue</strong>(Object value)</p></li><li><p>boolean <strong>isEmpty</strong>()</p><p><strong>4、元视图操作的方法：</strong></p></li><li><p><code>Set&lt;K&gt;</code>  <strong>keySet</strong>()</p></li><li><p><code>Collection&lt;V&gt;</code> <strong>values</strong>()</p></li><li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code> <strong>entrySet</strong>()</p><p><strong>5、其他方法</strong></p></li><li><p>int <strong>size</strong>()</p></li></ul><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中</p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-map集合的遍历">3. Map集合的遍历：<a class="hash-link" href="#3-map集合的遍历" title="Direct link to heading">​</a></h4><p>Collection集合的遍历：（1）foreach（2）通过Iterator对象遍历</p><p>Map的遍历，不能支持foreach，因为Map接口没有继承 <code>java.lang.Iterable&lt;T&gt;</code> 接口，也没有实现Iterator iterator()方法。只能用如下方式遍历：</p><p>（1）分开遍历：</p><ul><li>单独遍历所有key</li><li>单独遍历所有value</li></ul><p>（2）成对遍历：</p><ul><li>遍历的是映射关系Map.Entry类型的对象，Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类。在Map中存储数据，实际上是将Key----&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</li></ul><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestMap {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;许仙&quot;, &quot;白娘子&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;董永&quot;, &quot;七仙女&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;牛郎&quot;, &quot;织女&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;许仙&quot;, &quot;小青&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;所有的key:&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;String&gt; keySet = map.keySet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String key : keySet) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;所有的value：&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collection&lt;String&gt; values = map.values();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String value : values) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;所有的映射关系&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Map.Entry&lt;String,String&gt; entry : entrySet) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          System.out.println(entry);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(entry.getKey()+&quot;-&gt;&quot;+entry.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="4-hashmap-和-hashtable">4. HashMap 和 Hashtable：<a class="hash-link" href="#4-hashmap-和-hashtable" title="Direct link to heading">​</a></h4><p>HashMap和Hashtable都是哈希表。</p><p>HashMap和Hashtable判断两个 key 相等的标准是：<strong>两个 key 的hashCode 值相等，并且 equals() 方法也返回 true</strong>。因此，为了成功地在哈希表中存储和获取对象，<strong>用作键的对象必须实现 hashCode 方法和 equals 方法</strong></p><p>Hashtable是<strong>线程安全的，任何非 null 对象都可以用作键或值</strong></p><p>HashMap是<strong>线程不安全的，并允许使用 null 值和 null 键</strong></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="5-linkedhashmap">5. LinkedHashMap：<a class="hash-link" href="#5-linkedhashmap" title="Direct link to heading">​</a></h4><p>LinkedHashMap 是 <strong>HashMap</strong> 的子类。此实现与 HashMap 的不同之处在于，<strong>后者维护着一个运行于所有条目的双重链接列表</strong>。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="6-treemap">6. TreeMap：<a class="hash-link" href="#6-treemap" title="Direct link to heading">​</a></h4><p>基于<strong>红黑树</strong>（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="7-properties">7. Properties：<a class="hash-link" href="#7-properties" title="Direct link to heading">​</a></h4><p>Properties 类是 <strong>Hashtable</strong> 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串</p><p>存取数据时，建议使用 <strong>setProperty</strong>(String key,String value) 方法和 <strong>getProperty</strong>(String key)  方法</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="8-set集合与map集合的关系">8. Set集合与Map集合的关系：<a class="hash-link" href="#8-set集合与map集合的关系" title="Direct link to heading">​</a></h4><p><strong>Set的内部实现其实是一个Map</strong>。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="9-hashmap源码分析">9. HashMap源码分析：<a class="hash-link" href="#9-hashmap源码分析" title="Direct link to heading">​</a></h4><p>存储到HashMap中的映射关系(key,value)，其中的key的hashCode值和equals方法非常重要</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="1-hashcode值">1. hashCode值：<a class="hash-link" href="#1-hashcode值" title="Direct link to heading">​</a></h5><p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="2-hash表的物理结构">2. Hash表的物理结构：<a class="hash-link" href="#2-hash表的物理结构" title="Direct link to heading">​</a></h5><p>HashMap和Hashtable是散列表，其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个元素被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到了某个table<!-- -->[index]<!-- -->桶中。使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table<!-- -->[index]</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="3-原理分析">3. 原理分析：<a class="hash-link" href="#3-原理分析" title="Direct link to heading">​</a></h5><p>（1）<strong>创建HashMap对象时候，初始化几个值</strong>，</p><ul><li>主要：table代表数组默认null，负载因子默认0.75，边界值0    </li></ul><p>（2）<strong>第一次向HashMap添加元素</strong></p><ul><li>根据添加数据key计算hash值</li><li>判断当前table数组是否为空，第一次肯定是空，数组进行初始化<br>-- <strong>数组容量 16 ，临界值 12</strong></li><li>根据数组初始长度和hash值得到数组某个位置，在位置添加元素（第一次加不存在重复问题）</li></ul><p>（3）<strong>容量不超过临界值12时候，再次添加数据</strong></p><ul><li>根据添加数据key计算hash值</li><li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>-- 判断数组这个位置上面是否存在元素，如果不存在，添加<br>-- 如果位置存在元素，<br>--- <strong>判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储</strong>      </li></ul><p>（4）<strong>容量超过临界值12，添加数据</strong> </p><ul><li>根据添加数据key计算hash值</li><li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>-- 判断数组这个位置上面是否存在元素，如果不存在，添加<br>-- 如果位置存在元素，<br>--- <strong>判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储</strong><br>-- <strong>判断数组容量是否超过临界值，如果超过进行扩容</strong><br>--- <strong>把数组大小2倍，临界值2倍</strong><br>--- <strong>把数组元素重新编排</strong>     </li></ul><p>（5）在jdk1.8优化</p><ul><li><strong>如果数组容量64，链表节点8，把链表转换树形结构</strong></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="4-什么时候树化什么时候反树化">4. 什么时候树化？什么时候反树化？<a class="hash-link" href="#4-什么时候树化什么时候反树化" title="Direct link to heading">​</a></h5><ul><li><p>当某table<!-- -->[index]<!-- -->下的链表的结点个数达到8，并且table.length&gt;=64，那么如果新Entry对象还添加到该table<!-- -->[index]<!-- -->中，那么就会将table<!-- -->[index]<!-- -->的链表进行树化。</p></li><li><p>当某table<!-- -->[index]<!-- -->下的红黑树结点个数少于6个，此时，</p><ul><li>如果继续删除table<!-- -->[index]<!-- -->下树结点，一直删除到2个以下时就会变回链表。</li><li>如果继续添加映射关系到当前map中，如果添加导致了map的table重新resize，那么只要table<!-- -->[index]<!-- -->下的树结点仍然&lt;=6个，那么会变回链表</li></ul></li></ul><h5 class="anchor anchorWithStickyNavbar_mojV" id="5-关于映射关系的key是否可以修改">5. 关于映射关系的key是否可以修改？<a class="hash-link" href="#5-关于映射关系的key是否可以修改" title="Direct link to heading">​</a></h5><p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上</p><p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="8-collections工具类">8. Collections工具类：<a class="hash-link" href="#8-collections工具类" title="Direct link to heading">​</a></h3><p>参考操作数组的工具类：Arrays。</p><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)根据元素的自然顺序对指定 List 集合元素按升序排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" title="Copy" class="copyButton_eDfN clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/learn/Java/基础/泛型"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">泛型</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/learn/Java/基础/文件与IO"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">文件与IO</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-数据结构" class="table-of-contents__link toc-highlight">1. 数据结构：</a></li><li><a href="#2-集合概述" class="table-of-contents__link toc-highlight">2. 集合概述：</a></li><li><a href="#3-collection-常用方法" class="table-of-contents__link toc-highlight">3. Collection 常用方法：</a></li><li><a href="#4-iterator迭代器" class="table-of-contents__link toc-highlight">4. Iterator迭代器：</a></li><li><a href="#5-list集合" class="table-of-contents__link toc-highlight">5. List集合：</a></li><li><a href="#6-set集合" class="table-of-contents__link toc-highlight">6. Set集合：</a></li><li><a href="#7-map集合" class="table-of-contents__link toc-highlight">7. Map集合：</a></li><li><a href="#8-collections工具类" class="table-of-contents__link toc-highlight">8. Collections工具类：</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/learn/assets/js/runtime~main.033937ee.js"></script>
<script src="/learn/assets/js/main.4c2c454e.js"></script>
</body>
</html>